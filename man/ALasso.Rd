% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ALasso.R
\name{ALasso}
\alias{ALasso}
\title{Adaptive Lasso}
\usage{
ALasso(formula, data, weights, subset = NULL, na.action = na.omit,
  offset = NULL, standardize = TRUE, family = c("poisson", "negbin",
  "geometric"), link = c("logit", "probit", "cloglog", "cauchit", "log"),
  control = zeroinfl.control(...), penalty = c("enet", "mnet", "snet"),
  start = NULL, model = TRUE, y = TRUE, x = FALSE, nlambda = 100,
  lambda.count = NULL, lambda.zero = NULL, penalty.factor.count = NULL,
  penalty.factor.zero = NULL, lambda.count.min.ratio = 1e-04,
  lambda.zero.min.ratio = 0.1, alpha.count = 1, alpha.zero = alpha.count,
  gamma.count = 3, gamma.zero = gamma.count, rescale = FALSE, init.theta,
  theta.fixed = FALSE, EM = TRUE, maxit.em = 200, convtype = c("count",
  "both"), maxit = 1000, maxit.theta = 1, reltol = 1e-05,
  eps.bino = 1e-05, shortlist = FALSE, trace = FALSE)
}
\arguments{
\item{formula}{symbolic description of the model, see details.}

\item{data, subset, na.action}{arguments controlling formula processing via \eqn{model.frame}.}

\item{weights}{optional numeric vector of weights.}

\item{offset}{optional numeric vector with an a priori known component to be included in the linear predictor of the count model. See below for more information on offsets.}

\item{standardize}{Logical flag for x variable standardization, prior to fitting the model sequence. The coefficients are always returned on the original scale. Default is \eqn{standardize=TRUE}.}

\item{family}{character specification of count model family (a log link is always used).}

\item{link}{character specification of link function in the binary zero-inflation model (a binomial family is always used).}

\item{control}{a list of control arguments specified via \eqn{zeroinfl.control}.}

\item{penalty}{penalty considered as one of \eqn{enet}, \eqn{mnet}, \eqn{snet}.}

\item{start}{starting values for the parameters in the linear predictor.}

\item{model, y, x}{logicals. If TRUE the corresponding components of the fit (model frame, response, model matrix) are returned.}

\item{nlambda}{number of \eqn{lambda} value, default value is 100. The sequence may be truncated before \eqn{nlambda} is reached if a close to saturated model for the zero component is fitted.}

\item{lambda.count}{A user supplied \eqn{lambda.count} sequence. Typical usage is to have the program compute its own \eqn{lambda.count} and \eqn{lambda.zero} sequence based on \eqn{nlambda} and \eqn{lambda.min.ratio}.}

\item{lambda.zero}{A user supplied \eqn{lambda.zero} sequence.}

\item{penalty.factor.count, penalty.factor.zero}{These are numeric vectors with the same length as predictor variables. that multiply \eqn{lambda.count},\eqn{lambda.zero}, respectively, to allow differential shrinkage of coefficients. Can be 0 for some variables, which implies no shrinkage, and that variable is always included in the model. Default is same shrinkage for all variables.}

\item{lambda.count.min.ratio, lambda.zero.min.ratio}{Smallest value for \eqn{lambda.count} and \eqn{lambda.zero}, respectively, as a fraction of \eqn{lambda.max}, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero except the intercepts). Note, there is a closed formula for \eqn{lambda.max} for \eqn{penalty="enet"}. If \eqn{rescale=TRUE}, \eqn{lambda.max} is the same for \eqn{penalty="mnet"} or \eqn{"snet"}. Otherwise, some modifications are required. In the current implementation, for small gamma value, the square root of the computed \eqn{lambda.zero[1]} is used when \eqn{penalty="mnet"} or \eqn{"snet"}.}

\item{alpha.count}{The elastic net mixing parameter for the count part of model.}

\item{alpha.zero}{The elastic net mixing parameter for the zero part of model.}

\item{gamma.count}{The tuning parameter of the snet or mnet penalty for the count part of model.}

\item{gamma.zero}{The tuning parameter of the snet or mnet penalty for the zero part of model.}

\item{rescale}{logical value, if TRUE, adaptive rescaling}

\item{init.theta}{The initial value of theta for \eqn{family="negbin"}.}

\item{theta.fixed}{Logical value only used for \eqn{family="negbin"}. If TRUE, theta is not updated.}

\item{EM}{Using EM algorithm. Not implemented otherwise}

\item{maxit.em}{Maximum number of EM algorithm}

\item{convtype}{convergency type, default is for count component only for speedy computation}

\item{maxit}{Maximum number of coordinate descent algorithm}

\item{maxit.theta}{Maximum number of iterations for estimating theta scaling parameter if \eqn{family=" negbin"}. Default value maxit.theta may be increased, yet may slow the algorithm}

\item{reltol}{Convergence criteria, default value \eqn{1e-5} may be reduced to make more accurate yet slow}

\item{eps.bino}{a lower bound of probabilities to be claimed as zero, for computing weights and related values when \eqn{family="binomial"}.}

\item{shortlist}{logical value, if TRUE, limited results return}

\item{trace}{If TRUE, progress of algorithm is reported}
}
\value{
The function ALasso returns a list of following components

\item{coefficients}{a list with elements \eqn{"count"} and \eqn{"zero"} containing the coefficients from the respective models,}

\item{residuals}{a vector of raw residuals (observed - fitted),}

\item{fitted.values}{a vector of fitted means,}

\item{weights}{the case weights used,}

\item{terms}{a list with elements \eqn{"count"}, \eqn{"zero"} and \eqn{"full"} containing the terms objects for the respective models,}

\item{theta}{estimate of the additional \eqn{\theta} parameter of the negative binomial model (if a negative binomial regression is used),}

\item{loglik}{log-likelihood of the fitted model,}

\item{family}{character string describing the count distribution used,}

\item{link}{character string describing the link of the zero-inflation model,}

\item{linkinv}{the inverse link function corresponding to link,}

\item{converged}{logical value, TRUE indicating successful convergence of \eqn{ALasso}, FALSE indicating otherwise}

\item{call}{the original function call}

\item{formula}{the original formula}

\item{levels}{levels of the categorical regressors}

\item{contrasts}{a list with elements \eqn{"count"} and \eqn{"zero"} containing the contrasts corresponding to levels from the respective models,}

\item{model}{the full model frame \eqn{(if model = TRUE)},}

\item{y}{the response count vector \eqn{(if y = TRUE)},}

\item{x}{a list with elements \eqn{"count"} and \eqn{"zero"} containing the model matrices fromthe respective models \eqn{(if x = TRUE)},}
}
\description{
Adaptive Lasso for Zero-inflated Count Regression fits zero-inflated regression models for count data via penalized maximum likelihood.
}
\details{
The algorithm fits penalized zero-inflated count data regression models using the coordinate descent algorithm within the EM algorithm. The returned fitted model object is of class \eqn{"ALasso"} and is similar to fitted \eqn{"glm"} and \eqn{"zeroinfl"} objects. For elements such as \eqn{"coefficients"} a list is returned with elements for the \eqn{zero} and \eqn{count} component, respectively.
}
\examples{

data("docvisits", package = "zic")
## with simple inflation (no regressors for zero component)
AL_zip <- ALasso(docvisits ~ . | ., data = docvisits, family = "poisson", nlambda = 10)
summary(AL_zip)
AL_zinb <- ALasso(docvisits ~ . | ., data = docvisits, family = "negbin", nlambda=10)
summary(AL_zinb)
}
